# ‚úÖ RoomVibe ‚Äî TASK 5: Gallery Lighting (Strict 1 Artwork = 1 Spotlight)

**VA≈ΩNO:** Raditi na stabilnom snapshotu (non-black room). Ako se pojavi ‚Äúcrna soba‚Äù, odmah rollback na stabilni snapshot i nastaviti.

---

## üÜï TASK 5.1 ‚Äî Strict ‚Äú1 Artwork = 1 Spotlight‚Äù (Final discipline)

### Problem

Trenutno spotlightovi djeluju kao generiƒçki pattern po zidu: jedan snop pogaƒëa vi≈°e radova ili osvjetljava prazninu. To izgleda nerealno.

### Goal

Uvesti **strogo pravilo**: **svaki artwork slot dobije toƒçno 1 spotlight** koji cilja **toƒçan centar** tog artworka.

### MUST

1. **Disable/Remove legacy static spotlights**

* Ako u sceni postoji stari set spotova (hardcoded), privremeno ga ugasiti ili ukloniti.
* Ostaviti samo fill (ambient/hemisphere) dok se novi spotovi ne potvrde.

2. **Generate spotlights only from active artwork slots**

* `artworkSlots.filter(s => s.hasArtwork)`
* Za svaki slot generirati 1 spotlight.

3. **Each spotlight targets world-center of artwork**

* Target mora biti zasebni Object3D u scene graphu.
* U `useFrame` raditi `light.target.updateMatrixWorld()`.

4. **Cone discipline**

* U≈æi angle (gallery feel): npr. `Math.PI/10` do `Math.PI/8`
* Penumbra: 0.6‚Äì0.75
* Distance: dovoljno (12‚Äì18), bez pretjerivanja.

5. **Never-black guarantee**

* `ambientLight` ili `hemisphereLight` mora ostati ukljuƒçen:

  * intensity 0.22‚Äì0.35

### Stop conditions

* [ ] Nijedan spotlight ne osvjetljava dvije slike
* [ ] Svaka slika ima smislen ‚Äúown light‚Äù
* [ ] Nema crne sobe
* [ ] Screenshot Center + Side view

---

## üë©‚Äçüíª Code helper: Strict generator (drop-in pattern)

> Agent: prilagodi imenima varijabli/slotova u projektu. Logika je bitna.

```tsx
// 1) Keep a minimal fill to prevent black-room regression
<ambientLight intensity={0.28} />

// 2) Legacy lights OFF (example)
// If you have something like <LegacySpotlights enabled />, set enabled={false}
// or remove them when strict mode is active.

// 3) Strict: 1 artwork = 1 spotlight
{artworkSlots
  .filter((s) => s.hasArtwork)
  .map((slot) => {
    const targetWorld = getWorldCenter(slot.artworkObject3D);

    const ceilingY = GALLERY_CEILING_Y; // e.g. 4.8‚Äì5.2 depending on ceiling
    const offsetFromWall = 0.35;

    // wallNormal should point *out* from wall into the room
    const n = slot.wallNormal.clone().normalize();

    const lightWorld = targetWorld
      .clone()
      .add(n.clone().multiplyScalar(offsetFromWall))
      .setY(ceilingY - 0.2);

    return (
      <AutoSpotlight
        key={slot.id}
        targetWorld={targetWorld}
        lightWorld={lightWorld}
        intensity={1.25}
        angle={Math.PI / 9}
        penumbra={0.7}
        distance={16}
        castShadow
      />
    );
  })}
```

### Debug tip (if lights aim wrong)

* Vizualiziraj wallNormal orijentaciju: ako je normal okrenuta prema zidu, offset ide "iza" zida ‚Üí svjetlo neƒáe raditi.
* U tom sluƒçaju invertirati normalu: `n.multiplyScalar(-1)`.
