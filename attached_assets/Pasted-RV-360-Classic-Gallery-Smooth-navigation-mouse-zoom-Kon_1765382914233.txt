RV â€“ 360 Classic Gallery â€“ Smooth navigation & mouse zoom

**Kontekst (trenutno stanje)**

* Radimo u **Classic Gallery** preset-u u 360Â° Editoru.
* Hotspotovi (krugovi na podu) su vidljivi i klikom se kamera premjeÅ¡ta na razliÄite pozicije (Entrance, Center, Back Left, Back Right).
* Korisnik moÅ¾e rotirati pogled miÅ¡em.
* OgraniÄenja trenutne verzije:

  * prijelazi izmeÄ‘u pozicija su **grubi / instantni**, bez smooth animacije
  * kretanje je moguÄ‡e **samo skokovito** (od toÄke do toÄke), nema osjeÄ‡aja da se "Å¡etamo" kroz prostor
  * scroll / zoom miÅ¡em ne pribliÅ¾ava se slici, veÄ‡ je korisnik prisiljen skakati s jedne toÄke na drugu
  * granice prostora su ok, ne smije se izaÄ‡i iz galerije â€“ to trebamo zadrÅ¾ati

Cilj ovog taska:

1. Uvesti **glatke, animirane prijelaze** kamere izmeÄ‘u view point-ova (hotspotovi + gumbi Entrance/Center/Back Left/Back Right).
2. OmoguÄ‡iti **zoom naprijed/nazad kotaÄiÄ‡em miÅ¡a** (scroll) duÅ¾ smjera gledanja, uz ograniÄenja da korisnik ne proÄ‘e kroz zid ili ne ode predaleko.
3. ZadrÅ¾ati postojeÄ‡e granice prostora i postojeÄ‡i layout.

---

## 1. Smooth prijelaz kamere izmeÄ‘u view point-ova

**File:** `src/components/360/Gallery360Scene.tsx`

Umjesto trenutnog instant pomaka kamere na novu poziciju, trebaÅ¡ uvesti **interpolaciju (lerp)** kroz odreÄ‘eno vrijeme.

### 1.1. Dodaj konstante za navigaciju

Na vrh file-a (ili blizu postojeÄ‡ih 360 konstanti) dodaj neÅ¡to u ovom stilu:

```ts
const CAMERA_MOVE_DURATION = 0.6; // u sekundama, osjeÄ‡aj "laganog klizanja"
const CAMERA_HEIGHT = 1.65;      // visina "oÄiju" (ostavi ako veÄ‡ postoji sliÄno)
```

Ako veÄ‡ postoje konstante za height, moÅ¾eÅ¡ ih iskoristiti / uskladiti.

### 1.2. Refovi za kameru i animaciju

U React komponenti gdje se definira 360 scena (Classic Gallery), dodaj ref-ove i state potrebne za glatko kretanje:

```ts
const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
const [activeView, setActiveView] = useState<ViewpointKey>("entrance");

const targetPositionRef = useRef<THREE.Vector3 | null>(null);
const moveStartTimeRef = useRef<number | null>(null);
```

Pretpostavka: veÄ‡ postoji neka mapa `VIEWPOINTS` ili sliÄno (Entrance, Center, BackLeft, BackRight) koja definira XYZ pozicije. Ako ne postoji, koristi postojeÄ‡i naÄin na koji odreÄ‘ujeÅ¡ poziciju kamere, samo ga prebaci na ovaj novi model.

### 1.3. Funkcija za pokretanje kretanja kamere

Definiraj helper funkciju unutar komponente:

```ts
const goToView = (key: ViewpointKey) => {
  const base = VIEWPOINTS[key]; // npr. { x, y, z }
  if (!cameraRef.current || !base) return;

  const start = cameraRef.current.position.clone();
  const target = new THREE.Vector3(base.x, CAMERA_HEIGHT, base.z);

  targetPositionRef.current = target;
  moveStartTimeRef.current = performance.now();
  setActiveView(key);
};
```

Ako veÄ‡ postoji `goToView` / sliÄno, prilagodi ga tako da **ne postavlja odmah `camera.position`**, nego radi ovo gore.

### 1.4. Animacija u `useFrame`

U istom komponentu koristiÅ¡ `useFrame`. Tu trebaÅ¡ interpolirati izmeÄ‘u trenutne i ciljane pozicije:

```ts
useFrame(({ clock }) => {
  const camera = cameraRef.current;
  if (!camera) return;

  if (targetPositionRef.current && moveStartTimeRef.current !== null) {
    const elapsed = (performance.now() - moveStartTimeRef.current) / 1000;
    const t = Math.min(elapsed / CAMERA_MOVE_DURATION, 1);

    // ease-in-out (moÅ¾eÅ¡ zamijeniti vlastitom funkcijom ako veÄ‡ koristiÅ¡ neku easing util)
    const easedT = t * t * (3 - 2 * t);

    camera.position.lerp(targetPositionRef.current, easedT);

    if (t >= 1) {
      // animacija gotova
      moveStartTimeRef.current = null;
    }
  }
});
```

Ako veÄ‡ imate globalni `useFrame` za rotaciju ili sl., integriraj ovaj dio u postojeÄ‡i `useFrame` blok, nemoj kreirati dupli.

### 1.5. PoveÅ¾i hotspotove i gumbe s `goToView`

* Hotspotovi na podu (plavi / Å¾uti krugovi) trebaju na klik pozivati `goToView("center")`, `goToView("entrance")`, itd. ovisno o tipu hotspot-a.
* Gumbi dolje (Entrance / Center / Back Left / Back Right) isto moraju pozivati `goToView` s odgovarajuÄ‡im kljuÄem, **ne smiju direktno postavljati kameru**.

Primjer handlera:

```ts
const handleHotspotClick = (key: ViewpointKey) => {
  goToView(key);
};

// Button
<Button onClick={() => goToView("center")}>Center</Button>
```

Rezultat: svaki klik na hotspot ili gumb = glatko, animirano pomicanje kamere izmeÄ‘u pozicija, bez grubog skoka.

---

## 2. Zoom kotaÄiÄ‡em miÅ¡a (scroll dolly)

Cilj: korisnik moÅ¾e **priÄ‡i bliÅ¾e ili se udaljiti** od trenutnog viewa samo kotaÄiÄ‡em miÅ¡a, bez promjene view point-a.

### 2.1. Konstante za granice

Negdje blizu navigacijskih konstanti dodaj:

```ts
const CAMERA_MIN_DISTANCE = 3.0;  // minimalna udaljenost od "centra" / fokusne toÄke
const CAMERA_MAX_DISTANCE = 12.0; // maksimalna udaljenost (da ne ode predaleko)
```

Ove vrijednosti prilagodi prema trenutnom scale-u galerije.

### 2.2. Handler za wheel event

Na wrapper komponentu za 360 scenu (gdje se hvata mouse interakcija) dodaj `onWheel` handler.

Pseudokod:

```ts
const handleWheel: WheelEventHandler<HTMLDivElement> = (event) => {
  const camera = cameraRef.current;
  if (!camera) return;

  // event.deltaY > 0 = scroll down (udaljavanje), < 0 = pribliÅ¾avanje
  const direction = new THREE.Vector3();
  camera.getWorldDirection(direction); // smjer gledanja

  const step = event.deltaY * 0.0025; // osjeti se kao lagani zoom, moÅ¾eÅ¡ prilagoditi
  const newPosition = camera.position.clone().add(direction.multiplyScalar(step));

  // ograniÄi kretanje unutar min/max distance
  const distanceFromCenter = newPosition.length();
  if (distanceFromCenter < CAMERA_MIN_DISTANCE || distanceFromCenter > CAMERA_MAX_DISTANCE) {
    return;
  }

  camera.position.copy(newPosition);
};
```

Primijeni ovaj handler na glavni container koji veÄ‡ hvata klikove / drag za rotaciju (npr. `<div onWheel={handleWheel}>â€¦</div>`).

VaÅ¾no: ovaj zoom ne smije probiti zidove. Ako veÄ‡ imate bounding box za galeriju, moÅ¾eÅ¡ umjesto `distanceFromCenter` koristiti provjeru da `newPosition` ostaje unutar tog bounding boxa.

---

## 3. Kontrole miÅ¡a â€“ opÄ‡i osjeÄ‡aj

* Ostavi postojeÄ‡i drag za rotaciju kamere, ali provjeri da je **osjetljivost** ugodna (ne presporo, ne prebrzo).
* macOS ima tzv. *natural scrolling* (scroll u jednom smjeru pomiÄe sadrÅ¾aj "kontra" oÄekivanog na Windowsima) â€“ to je sistemska postavka i ne treba je ruÄno mijenjati u app-u.
* Bitno nam je da **lijevi klik + drag** rotira pogled, dok scroll samo pribliÅ¾ava/udaljava, bez skokova.

---

## 4. Å to testirati nakon implementacije

Nakon Å¡to zavrÅ¡iÅ¡, ja Ä‡u testirati sljedeÄ‡e u **Classic Gallery**:

1. Vidim hotspotove na podu (Entrance, Center, Back Left, Back Right).
2. Klik na bilo koji hotspot:

   * kamera se pomiÄe kroz ~0.6 s glatko (ease-in-out), ne skokovito
   * mogu odmah nakon toga rotirati pogled miÅ¡em
3. Klik na gumbe dolje (Entrance/Center/Back Left/Back Right) daje isti glatki efekt kao klik na hotspot.
4. Scroll kotaÄiÄ‡em miÅ¡a:

   * pribliÅ¾ava/udaljava se duÅ¾ smjera gledanja
   * ne mogu proÄ‡i kroz zid
   * ne mogu otiÄ‡i predaleko (osjeÄ‡aj je kao kontrolirani zoom)
5. JoÅ¡ uvijek **ne mogu napustiti galeriju** (nema crnog svemira, nema bijelog beskonaÄnog poda, ostajem u prostoru).

Ako neÅ¡to od ovoga ne radi, molim te dodaj kratke debug logove u konzolu (npr. `[CameraNav] goToView entrance`, `[CameraNav] wheel deltaY=â€¦`) kako bismo mogli lakÅ¡e uoÄiti problem.

Hvala! ğŸ˜Š
